SuccessorML
===========

The purpose of http://successor-ml.org[successor ML], or sML for
short, is to provide a vehicle for the continued evolution of ML,
using Standard ML as a starting point. The intention is for successor
ML to be a living, evolving dialect of ML that is responsive to
community needs and advances in language design, implementation, and
semantics.

== SuccessorML Features in MLton ==

The following SuccessorML features have been implemented in MLton.
The features are disabled by default, for information about enabling
these features see their corresponding <:MLBasisAnnotations:>.

* Do Declarations
+
Evaluating functions for their side effects is a common idiom seen
in SML.  This feature allows for the same functionality but in an
alternative syntax.  It is requried that the expression being
evaluated has the type of unit in order to use a do declaration.
+
Commonly one may perform either of the following:
+
----
val _ = print "Hello world.\n"
val () = print "Hello world.\n"
----
+
Instead the following syntax may be used:
+
----
do print "Hello world.\n"
----

* Extended Literals
+
This feature allows for binary literals to be used.
Additionally underscores may be used throughout
literals to group digits together for convenience.
+
Below are some examples of extended literal syntax.
+
----
val b = 0b10101
val bw = 0wb1010
val x = 4_327_829
----

* Line Comments
+
Line comments may be may be started with ++(*)++.
+
----
(*) This is a line comment
----
+
Please note that with this feature enabled the following
SML code which would previously compile will now result
in a compilation error.
+
----
(*)
val x = 0 (*) This line is no-longer part of a block comment
*)
----

* Optional Pattern Bars
+
A bar may be optionally placed before the first rule of a match.
By eliminating the special case of the first match requiring no
bar, this allows for easier refactoring.
+
----
case exp of
  | A => 1
  | B => 2
  | C => 3
----
+
This optional bar may also be placed for `fn` and `handle`,
function declarations, and `datatype` declarations.

* Optional Semicolons
+
In the same spirit, a semicolon may be optionally placed
after the the last expression in a sequence.
+
----
let
   val x = 3
in
   f x;
   g x;
end
----

* Disjunctive (Or) Patterns
+
This feature allows for being able to utilize ``or-patterns''.
One can ``or'' multiple matches together without having to re-write
the same resultant right-hand-side expression.  Note that
disjunctive patterns require an additional surrounding parenthesis.
+
For example `exp` could be matched as follows:
+
----
case exp of
    (A | B | C) =>  1
  | (D | E) => 2
----

* Record Punning
+
Records with fields that are of the form id=id can be abbreviated
to id.  Previously this was only allowed in patterns.
+
For example:
+
----
fn {a, b, c} => {a=a, b=b+1, c=c}
----
+
Could be abbreviated to:
+
----
fn {a, b, c} => {a, b=b+1, c}
----

* Withtype for Signatures
+
This feature allows for the use of the `withtype` keyword in
signatures.  Previously, `withtype` was only allowed in structures.
+
----
signature S =
   sig
      datatype a = A1 of int | A2 of int * t
      withtype t = int * a option
   end
----
